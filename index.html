<!-- Based off of https://github.com/austinEng/webgpu-samples/blob/master/compute_boids.html -->
<!DOCTYPE html>
<html lang="en">
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>boids</title>

<style>
html, body, canvas {
  margin:0px;
  padding: 0px;
  width:100%;
  height:100%;
}
#webgpu_error {
  display: none;
}
</style>

<body>
  <span id="webgpu_error"></span>
  <canvas></canvas>

<script>
function webgpu_error(str)
{
  document.getElementById("webgpu_error").innerText = "webgpu error: [ "+str+" ]";
  document.getElementById("webgpu_error").style.display = 'inline';
}

const numParticles = 1000;

const wgslShaders = {
  vertex: `
struct position_out {
  [[builtin(position)]] position : vec4<f32>;
  [[location(0)]] v_position : vec3<f32>;
};
[[stage(vertex)]]
fn main([[location(0)]] a_particlePos : vec2<f32>,
             [[location(1)]] a_particleVel : vec2<f32>,
             [[location(2)]] a_pos : vec2<f32>) -> position_out {
  var angle = -atan2(a_particleVel.x, a_particleVel.y);
  var pos = vec2<f32>(
      (a_pos.x * cos(angle)) - (a_pos.y * sin(angle)),
      (a_pos.x * sin(angle)) + (a_pos.y * cos(angle)));
  var output : position_out;
  output.position = vec4<f32>(pos + a_particlePos, 0.0, 1.0);
  output.v_position = vec3<f32>(pos + a_particlePos, 0.0);
  return output;
}
`,

  fragment: `
struct position_in {
  [[builtin(position)]] position : vec4<f32>;
  [[location(0)]] v_position : vec3<f32>;
};
[[stage(fragment)]]
fn main(input : position_in) -> [[location(0)]] vec4<f32> {
//  return vec4<f32>(1.0, 0.0, 0.0, 1.0);
  return vec4<f32>(input.v_position.x, input.v_position.y, 1.0, 1.0);
}
`,

  compute: `
struct Particle {
  pos : vec2<f32>;
  vel : vec2<f32>;
};
[[block]] struct SimParams {
  deltaT : f32;
  rule1Distance : f32;
  rule2Distance : f32;
  rule3Distance : f32;
  rule1Scale : f32;
  rule2Scale : f32;
  rule3Scale : f32;
};
[[block]] struct Particles {
  particles : [[stride(16)]] array<Particle>;//, ${numParticles}>;
};
[[binding(0), group(0)]] var<uniform> params : SimParams;
[[binding(1), group(0)]] var<storage, read> particlesA : Particles;
[[binding(2), group(0)]] var<storage, read_write> particlesB : Particles;

// https://github.com/austinEng/Project6-Vulkan-Flocking/blob/master/data/shaders/computeparticles/particle.comp
[[stage(compute)]]
fn main([[builtin(global_invocation_id)]] GlobalInvocationID : vec3<u32>) {
  var index : u32 = GlobalInvocationID.x;
  if (index >= ${numParticles}u) {
    return;
  }
  var vPos : vec2<f32> = particlesA.particles[index].pos;
  var vVel : vec2<f32> = particlesA.particles[index].vel;
  var cMass : vec2<f32> = vec2<f32>(0.0, 0.0);
  var cVel : vec2<f32> = vec2<f32>(0.0, 0.0);
  var colVel : vec2<f32> = vec2<f32>(0.0, 0.0);
  var cMassCount : u32 = 0u;
  var cVelCount : u32 = 0u;
  var pos : vec2<f32>;
  var vel : vec2<f32>;

  for (var i : u32 = 0u; i < ${numParticles}u; i = i + 1u) {
    if (i == index) {
      continue;
    }

    pos = particlesA.particles[i].pos.xy;
    vel = particlesA.particles[i].vel.xy;
    if (distance(pos, vPos) < params.rule1Distance) {
      cMass = cMass + pos;
      cMassCount = cMassCount + 1u;
    }
    if (distance(pos, vPos) < params.rule2Distance) {
      colVel = colVel - (pos - vPos);
    }
    if (distance(pos, vPos) < params.rule3Distance) {
      cVel = cVel + vel;
      cVelCount = cVelCount + 1u;
    }
  }
  if (cMassCount > 0u) {
    var temp : f32 = f32(cMassCount);
    cMass = (cMass / vec2<f32>(temp, temp)) - vPos;
    // cMass =
    //  (cMass / vec2<f32>(f32(cMassCount), f32(cMassCount))) - vPos;
  }

  if (cVelCount > 0u) {
    var temp : f32 = f32(cVelCount);
    cVel = cVel / vec2<f32>(temp, temp);
    // cVel = cVel / vec2<f32>(f32(cVelCount), f32(cVelCount));
  }

  vVel = vVel + (cMass * params.rule1Scale) + (colVel * params.rule2Scale) +
      (cVel * params.rule3Scale);

  // clamp velocity for a more pleasing simulation
  vVel = normalize(vVel) * clamp(length(vVel), 0.0, 0.1);
  // kinematic update
  vPos = vPos + (vVel * params.deltaT);
  // Wrap around boundary
  if (vPos.x < -1.0) {
    vPos.x = 1.0;
  }
  if (vPos.x > 1.0) {
    vPos.x = -1.0;
  }
  if (vPos.y < -1.0) {
    vPos.y = 1.0;
  }
  if (vPos.y > 1.0) {
    vPos.y = -1.0;
  }
  // Write back
  particlesB.particles[index].pos = vPos;
  particlesB.particles[index].vel = vVel;

  return;
}
`,
};

async function init() {
  console.log("init()");
  const canvas = document.querySelector('canvas');

  canvas.width = window.innerWidth;
  canvas.height = window.innerHeight;

  if (!navigator.gpu) { webgpu_error("!navigator.gpu"); return; }

  var adapter;
  try { adapter = await navigator.gpu.requestAdapter(); }
  catch (e) { webgpu_error(e); return; }
  if (!adapter) { webgpu_error("navigator.gpu.requestAdapter()"); return; }

  var device;
  try { device = await adapter.requestDevice(); }
  catch (e) { webgpu_error(e); return; }

  const context = canvas.getContext('gpupresent');
  if (!context) { webgpu_error("canvas.getContext('gpupresent')"); return; }

  const swapChain = context.configure({
    device,
    format: 'bgra8unorm',
  });

  const renderPipeline = device.createRenderPipeline({
    vertex: {
      module:
            device.createShaderModule({
            code: wgslShaders.vertex,
          }),
      entryPoint: 'main',
      buffers: [
        {
          // instanced particles buffer
          arrayStride: 4 * 4,
          stepMode: 'instance',
          attributes: [
            {
              // instance position
              shaderLocation: 0,
              offset: 0,
              format: 'float32x2',
            },
            {
              // instance velocity
              shaderLocation: 1,
              offset: 2 * 4,
              format: 'float32x2',
            },
          ],
        },
        {
          // vertex buffer
          arrayStride: 2 * 4,
          stepMode: 'vertex',
          attributes: [
            {
              // vertex positions
              shaderLocation: 2,
              offset: 0,
              format: 'float32x2',
            },
          ],
        },
      ],
    },
    fragment: {
      module:
          device.createShaderModule({
            code: wgslShaders.fragment,
          }),
      entryPoint: 'main',
      targets: [
        {
          format: 'bgra8unorm',
        },
      ],
    },
    primitive: {
      topology: 'triangle-list',
    },
  });

  const computePipeline = device.createComputePipeline({
    compute: {
      module:
          device.createShaderModule({
            code: wgslShaders.compute,
          }),
      entryPoint: 'main',
    },
  });

  const renderPassDescriptor = {
    colorAttachments: [
      {
        view: undefined, // Assigned later
        loadValue: { r: 0.0, g: 0.0, b: 0.0, a: 1.0 },
      },
    ],
  };

  function create_buffer(bufferData, usage)
  {
    const buffer = device.createBuffer({
      size: bufferData.byteLength,
      usage: usage,
      mappedAtCreation: true,
    });
    new Float32Array(buffer.getMappedRange()).set(bufferData);
    buffer.unmap();
    return buffer;
  }

  const vertexBufferData = new Float32Array([ -0.01, -0.02, 0.01, -0.02, 0.0, 0.02 ])
  const verticesBuffer = create_buffer(vertexBufferData, GPUBufferUsage.VERTEX);

  const simParamData = new Float32Array([
    0.04, // deltaT;
    0.1, // rule1Distance;
    0.025, // rule2Distance;
    0.025, // rule3Distance;
    0.02, // rule1Scale;
    0.05, // rule2Scale;
    0.005, // rule3Scale;
  ]);
  const simParamBuffer = create_buffer(simParamData, GPUBufferUsage.UNIFORM);

  const initialParticleData = new Float32Array(numParticles * 4);
  for (let i = 0; i < numParticles; ++i) {
    initialParticleData[4 * i + 0] = 2 * (Math.random() - 0.5);
    initialParticleData[4 * i + 1] = 2 * (Math.random() - 0.5);
    initialParticleData[4 * i + 2] = 2 * (Math.random() - 0.5) * 0.1;
    initialParticleData[4 * i + 3] = 2 * (Math.random() - 0.5) * 0.1;
  }
  const particleBuffers = new Array(2);
  const particleBindGroups = new Array(2);
  for (let i = 0; i < 2; ++i)
    particleBuffers[i] = create_buffer(initialParticleData,
              GPUBufferUsage.VERTEX | GPUBufferUsage.STORAGE);

  for (let i = 0; i < 2; ++i) {
    particleBindGroups[i] = device.createBindGroup({
      layout: computePipeline.getBindGroupLayout(0),
      entries: [
        {
          binding: 0,
          resource: {
            buffer: simParamBuffer,
            offset: 0,
            size: simParamData.byteLength,
          },
        },
        {
          binding: 1,
          resource: {
            buffer: particleBuffers[i],
            offset: 0,
            size: initialParticleData.byteLength,
          },
        },
        {
          binding: 2,
          resource: {
            buffer: particleBuffers[(i + 1) % 2],
            offset: 0,
            size: initialParticleData.byteLength,
          },
        },
      ],
    });
  }

  let t = 0;
  let now = Date.now();

  function frame() {
    renderPassDescriptor.colorAttachments[0].view = context
      .getCurrentTexture()
      .createView();

    const commandEncoder = device.createCommandEncoder();

    const passEncoder = commandEncoder.beginComputePass();
    passEncoder.setPipeline(computePipeline);
    passEncoder.setBindGroup(0, particleBindGroups[t % 2]);
    passEncoder.dispatch(numParticles);
    passEncoder.endPass();

    const passEncoder2 = commandEncoder.beginRenderPass(renderPassDescriptor);
    passEncoder2.setPipeline(renderPipeline);
    passEncoder2.setVertexBuffer(0, particleBuffers[(t + 1) % 2]);
    passEncoder2.setVertexBuffer(1, verticesBuffer);
    passEncoder2.draw(3, numParticles, 0, 0);
    passEncoder2.endPass();

    device.queue.submit([commandEncoder.finish()]);

    if ((t % 200) == 0) {
      let now_copy = now;
      now = Date.now();
      console.log((now - now_copy)/200.0+" fps");
    }
    ++t;
    requestAnimationFrame(frame);
  }

  requestAnimationFrame(frame);
}

init();

</script>

</body>

</html>
